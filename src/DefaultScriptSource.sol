// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import {IScriptSource} from "./IScriptSource.sol";

contract DefaultScriptSource is IScriptSource {
    string public script =
        "let audioContext;const generator=`\n  function genVariation() {\n    const timestamp = Date.now();\n    const angle = (timestamp % 20000) / 20000 * (2 * Math.PI);\n    return Math.sin(angle);\n  }\n\n  class RainSoundProcessor extends AudioWorkletProcessor {\n    constructor(params) {\n      super();\n\n      this.amplitude = (params.processorOptions.rainIntensity || 400) / 10000.0;\n      this.rainDistance = params.processorOptions.rainDistance || 8000;\n      this.sampleRate = 48000;\n      this.bufferSize = 256;\n      this.time = 0;\n      this.rainLeft = this.generateRain();\n      this.rainRight = this.generateRain();\n\n      this.lpFilter = this.createLowPassFilter(this.rainDistance);\n      this.lpFilterBufferLeft = new Float32Array(this.bufferSize);\n      this.lpFilterBufferRight = new Float32Array(this.bufferSize);\n    }\n\n    process(inputs, outputs, parameters) {\n      const output = outputs[0];\n      const outputChannelLeft = output[0];\n      const outputChannelRight = output[1];\n\n      for (let i = 0; i < this.bufferSize; ++i) {\n        const rainSampleLeft = this.rainLeft();\n        const rainSampleRight = this.rainRight();\n        this.lpFilterBufferLeft[i] = this.lpFilter(rainSampleLeft);\n        this.lpFilterBufferRight[i] = this.lpFilter(rainSampleRight);\n      }\n\n      for (let i = 0; i < outputChannelLeft.length; ++i) {\n        outputChannelLeft[i] = this.lpFilterBufferLeft[i % this.bufferSize];\n        outputChannelRight[i] = this.lpFilterBufferRight[i % this.bufferSize];\n      }\n \n      return true;\n    }\n\n    generateRain() {\n      let b0, b1, b2, b3, b4, b5, b6;\n      b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\n      return () => {\n        let white = Math.random() * 2 - 1;\n\n        b0 = 0.99886 * b0 + white * 0.0555179;\n        b1 = 0.89332 * b1 + white * 0.0750759;\n        b2 = 0.96900 * b2 + white * 0.1538520;\n        b3 = 0.86650 * b3 + white * 0.3104856;\n        b4 = 0.55000 * b4 + white * 0.5329522;\n        b5 = -0.7616 * b5 - white * 0.0168980;\n\n        let output = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n        b6 = white * 0.115926;\n\n        return (output * this.amplitude) * (1 + genVariation() * 0.1);\n      };\n    }\n\n    createLowPassFilter(cutoffFrequency) {\n      const RC = 1.0 / (cutoffFrequency * 2 * Math.PI);\n      const dt = 1.0 / this.sampleRate;\n      const alpha = dt / (RC + dt);\n\n      let y = 0;\n\n      return (input) => {\n        y = y + alpha * (input - y);\n        return y;\n      };\n    }\n  }\n\n  registerProcessor('rain-processor', RainSoundProcessor);\n`;async function initAudio(){const moduleUrl='data:application/javascript;base64,'+btoa(generator);audioContext=new(window.AudioContext||window.webkitAudioContext);await audioContext.audioWorklet.addModule(moduleUrl);const rainNode=new AudioWorkletNode(audioContext,'rain-processor',{outputChannelCount:[2],processorOptions:{...weather}});rainNode.connect(audioContext.destination)}function rotateGroups(){const rainCanvas=document.querySelector('#rain-canvas');const groups=rainCanvas.querySelectorAll('g');const copies=Array.from(groups).map(group=>group.cloneNode(true));groups.forEach((group,index)=>{const sourceOpacity=group.getAttribute('opacity');const sourceFilterClass=group.querySelector('use').getAttribute('class').split(' ').filter(x=>x.startsWith('f')).join(' ');const sourceTextTransform=group.querySelector('use').getAttribute('transform');const targetIndex=(index+1)%copies.length;const copy=copies[targetIndex];const targetClasses=copy.querySelector('use').getAttribute('class').split(' ').filter(x=>!x.startsWith('f')).join(' ');copy.setAttribute('opacity',sourceOpacity);copy.querySelector('use').setAttribute('class',`${sourceFilterClass} ${targetClasses}`);copy.querySelector('use').setAttribute('transform',sourceTextTransform)});groups.forEach((group,index)=>{const targetIndex=(index+1)%copies.length;group.remove();rainCanvas.appendChild(copies[targetIndex])})}let playing=false;let intervalCallback=undefined;document.onclick=async function(){document.getElementById('controls').style.visibility='hidden';if(!audioContext){await initAudio()}if(!playing){audioContext.resume().then(()=>{intervalCallback=setInterval(()=>{rotateGroups()},10)})}else{audioContext.suspend().then(()=>{clearInterval(intervalCallback)})}playing=!playing};function toggleFullScreen(){if(!document.fullscreenElement){document.documentElement.requestFullscreen()}else{if(document.exitFullscreen){document.exitFullscreen()}}}document.addEventListener('keydown',function(event){if(event.key.toLowerCase()==='f'){toggleFullScreen()}});document.addEventListener('DOMContentLoaded',function(){const controls=document.getElementById('controls');setTimeout(function(){controls.style.opacity=1;setTimeout(function(){controls.style.opacity=0},4e3)},1e3)});\n";
}
